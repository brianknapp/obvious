<!DOCTYPE html>
<html lang="en">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <title>Obvious by Retro Mocha</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Le styles -->
    <!--<link href="/css/bootstrap.css" rel="stylesheet">-->
    <link href="http://bootswatch.com/cosmo/bootstrap.min.css" rel="stylesheet">

    <link href='http://fonts.googleapis.com/css?family=Roboto:400,300,100' rel='stylesheet' type='text/css'>

    <style type="text/css">
      body {
        padding-top: 20px;
        padding-bottom: 40px;
        font-family: "Roboto";
      }

      h1, h2, h3, h4, h5, h6 {
        font-family: "Roboto";
      }


      .company_name {
        font-family: "Roboto";
        font-weight: 100;
        font-size: 38px;
        color: black;
        text-decoration: none !important;
      }

      .logo {
        float: left;
        position: relative;
        top: -19px;
        left: -10px;
      }

      .nav-pills>li.active>a, .nav-pills>li.active>a:hover, .nav-pills>li.active>a:focus {
        background-color: #33B5E5
      }

      a {
        color: #33B5E5;
      }

      /* Custom container */
      .container-narrow {
        margin: 0 auto;
        max-width: 900px;
      }
      .container-narrow > hr {
        margin: 50px 0;
      }

      /* Main marketing message and sign up button */
      .jumbotron {
        margin: 60px 0;
        text-align: center;
        background-color: #fafafa;
        width: 700px;
        margin-left: auto;
        margin-right: auto;
        padding-left: 80px;
        padding-right: 80px;
      }
      .jumbotron h1 {
        font-size: 72px;
        line-height: 1;
        font-weight: 100;
        font-family: "Roboto";
      }
      .jumbotron .btn {
        font-size: 21px;
        padding: 14px 24px;
      }

      /* Supporting marketing content */
      .marketing {
        margin: 60px 0;
      }
      .marketing p + h4 {
        margin-top: 28px;
      }

      p {
        font-size: 17px;
        line-height: 28px;
        margin-bottom: 20px;
        font-weight: 300;
      }
    </style>
    <link href="/css/bootstrap-responsive.css" rel="stylesheet">

    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="../assets/js/html5shiv.js"></script>
    <![endif]-->

    <!-- Fav and touch icons -->
    <!--<link rel="apple-touch-icon-precomposed" sizes="144x144" href="http://twitter.github.io/bootstrap/assets/ico/apple-touch-icon-144-precomposed.png">-->
    <!--<link rel="apple-touch-icon-precomposed" sizes="114x114" href="http://twitter.github.io/bootstrap/assets/ico/apple-touch-icon-114-precomposed.png">-->
      <!--<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://twitter.github.io/bootstrap/assets/ico/apple-touch-icon-72-precomposed.png">-->
                    <!--<link rel="apple-touch-icon-precomposed" href="http://twitter.github.io/bootstrap/assets/ico/apple-touch-icon-57-precomposed.png">-->
                                   <!--<link rel="shortcut icon" href="http://twitter.github.io/bootstrap/assets/ico/favicon.png">-->
  </head>

  <body>

    <div class="container-narrow">

 <div class="masthead">

        <a class="company_name" href="/">
          <h3 class="company_name">Obvious</h3>
        </a>
      </div>

      <hr>
    <div id="content-wrapper">
      <div class="inner clearfix">
        <section id="main-content">
          <h1>Welcome To Obvious</h1>

<p>Obvious is a clean architecture. The goal is to make it easy to write software using TDD and to expose the
intent of the software just by looking at the file structure. By using Obvious you also gain the benefit of having a
system that treats the external data sources and delivery mechanisms as implementation details that can be easily
replaced as needed.</p>

<center>
  <iframe width="560" height="315" src="https://www.youtube.com/embed/hxDDjVRUP1I" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</center>
<br>
<br>

<h2>Design Principles</h2>

<ul>
<li>Obvious Functionality</li>
<li>Framework Independence </li>
<li>Extreme Testability</li>
<li>Maintenance Minded</li>
</ul>

<h3>Obvious Functionality</h3>

<p>When looking at the app directory, it should be obvious what kinds of things the application does. This architecture highly values the "glance factor" of the application structure as well as being obvious in where to find things while working with the project.</p>

<h3>Framework Independence</h3>

<p>Your application does not need to be a web app, api app, desktop app, or console app. It also doesn't need to be a MySQL, MongoDB, or SQLServer app. Your app is just a set of data structures and functionality related to those data structures. How your app delivers your app or stores data are implementation details.  </p>

<p>Implementation details can and should change based on your implementation needs, your app logic shouldn't have to change when your implementation requirements do. </p>

<h3>Extreme Testability</h3>

<p>This is a TDD biased structure. Each layer and pattern is designed with testing in mind. More importantly, we designed this architecture so that testing would be easier for developers, which should lead to more testing and better software quality. </p>

<h3>Maintenance Minded</h3>

<p>When given the choice between short term productivity or long term maintenance, we believe that the right decision is long term maintenance. Many decisions have been made that are counterintuitive from a short term productivity standpoint, but allow for much easier maintenance. Obviousness, framework independence, and testability all work together to make the day to day maintenance more enjoyable. </p>

<h2>Structure</h2>

<p>There are three well defined folders of each Obvious project, which define the three core divisions of a given project - app, delivery, and
external. In the default Obvious structure, they exist as actual directories, but they are designed to be decoupled, so there is no reason
you couldn't put the app, external, or delivery mechanisms into separate gems if that made sense for your project, but for demonstration
purposes we assume them to all live in the same directory.</p>

<img src="images/obvious-architecture.png">

<h3>App</h3>

<p>App is where the entities, actions, and data contracts of your application are housed. </p>

<h4>Entities</h4>

<p>Entities represent data in your system. They are fairly simple data structures that mostly just contain data and do validation on
the data they contain. Simple entities usually only need a shape method to make writing contracts easier, a populate method of populating
the object, and a to_hash method for using the object elsewhere. </p>

<h4>Actions</h4>

<p>Actions are the use cases of the system. They are where most of the business logic of the system happens. They are single action objects
that take in Jacks as constructor arguments to enable pluggable data sources.  </p>

<h4>Contracts</h4>

<p>Contracts define the data transport structures and perform format validation on the hashes. Data flows through the contracts to
the jacks and plugs and back. Because the contracts validate both the input and the output, invalid data structures raise an error and
actions will fail. This ensures a standard mechanism for pluggable persistence.</p>

<h3>Delivery</h3>

<p>Delivery is where you implement the delivery mechanism of your application itself. Delivery is where your app is integrated with external
data sources and shown to the user.  This means in simplest terms the UI, but it also
means creating concrete versions of the external objects, such as data jacks, and also calling the actions of the app itself. </p>

<p>If your system contains multiple delivery mechanisms - multiple web apps, api's, command line apps, etc. each project would live in
a subdirectory of the delivery directory. In the example Obvious app below there is a sinatra app in delivery/web/, a sinatra json api
app in delivery/api/, a purple_shoes desktop app in delivery/desktop/ and a commander cli app in delivery/cli/. You also could make your app
and delivery directories into gems and have each delivery mechanism be its own directory.</p>

<h3>External</h3>

<p>External is where data transport between your app and various external infrastructure lives. This could be datbases, queues, or
caching layers connected to various data systems such as Redis, MongoDB, MySQL, the filesystem etc.</p>

<h4>Jacks</h4>

<p>Jacks are the classes that inherit from Contracts. A contract is designed to wrap a
jack method so that validation on the input and output hashes can be done. Jacks don't define a particular
 persistance mechanism, but instead act more as a routing mechaism to various plugs.</p>

<h4>Plugs</h4>

<p>Plugs are the objects that talk to external systems such as queues, databases, caching, 3rd party API's and so on. A single Jack
can have multiple plugs that plug into it. For example, you might have a BlogPostJack that has a BlogPostPlugForMySQL and a
BlogPostPlugForMongo and a BlogPostPlugForFS. In that scenario you could swap out MySQL for Mongo or the Filesystem at any time.</p>


<h2>Hashes as Data Transport</h2>

<p>The fundamental data structure of data transport between layers is a hash, ideally an immutable hash or struct. This is for both incoming and outgoing data from the
each layer.  There are many benefits to this approach. The biggest benefit is that each layer stays decoupled from the other layers
and that hashes act as messages passed between the layers. Immutable hashes or structs are preferable to mutable ones so that the messages stay in their original state.</p>

<p>Other benefits include:</p>

<p>Your delivery mechanism is only handed data, so you have less likelhood
of logic in your controllers or views (unless you do a bad thing). Your Jacks are only handed data, so contracts are able to validate
their structure to ensure that Jacks and Plugs won't break your system. Also, Plugs only handing back data means your application isn't
tied to the data structures of a particular ORM or persistence library. Lastly, entities are populated with hashes, so it is easy to
validate returned from the Jacks using the Entity.populate method.</p>

<h2>Examples</h2>

<p><strong><a href="http://github.com/RetroMocha/obvious_status">Obvious Status</a></strong> - A twitter clone status update app. It
is designed as an example app, so you can follow the commits to get an idea of how an app would progress step-by-step.</p>

<p>Currently Obvious Status can be run as a web app, JSON api, command line app, or a desktop app using jruby. Data can be stored with
JSON files, MySQL, MongoDB, or even the JSON api. You can pick from any of those options without changing your app folder code.</p>

<h2>Project Generator</h2>

<p>You can start using Obvious in Ruby by installing the ruby gem. Just 'gem install obvious'. To run it, call 'obvious generate' in a folder containing a "descriptors" folder with obvious yml descriptor files inside. The obvious generator will look at all of the action descriptors and will generate stub classes and pending tests for your project.</p>

<p><i>NOTE:</i> descriptors are awesome for getting a new app folder structure going, but are basically ignored after your app is created. At some point in the future, the Obvious app generator will get a bit smarter and descriptors could be useful in an ongoing design process, but for now they make bootstrapping easier and that's it.</p>

<h3>Example Descriptor File</h3>

<p>An <a href="https://gist.github.com/4367147">example obvious descriptor</a> file is available as a gist. It's a yaml file. It is designed to be for generate pseudocode and related tests. the c: elements are comments and the requires: elements determine what we think that method might need for that comment.</p>

<h2>Obvious Language Choice</h2>

<p>Obvious is written in Ruby, but there is nothing particularly language specific about the Obvious concepts and structure. The structure could be used effectively
in any object oriented language - PHP, Java, C#, Python, Scala, Lua, Javascript, ActionScript, Ruby, C++, or Smalltalk it doesn't matter. </p>


<h2>Credit</h2>

<h3>The Obvious Team:</h3>

<p><a href="http://twitter.com/_brianknapp">Brian Knapp</a>, <a href="https://twitter.com/shawnbaden">Shawn Baden</a>, and <a href="https://twitter.com/bryanthompson">Bryan Thompson</a></p>

<h3>Inspiration:</h3>

<p><a href="https://twitter.com/unclebobmartin">Uncle Bob Martin</a> - The <a href="confreaks.com/videos/759-rubymidwest2011-keynote-architecture-the-lost-years">keynote at Ruby Midwest 2011</a> outlined
the structure and ideas that became the Obvious Architecture. Uncle Bob's blog posts on <a href="http://blog.8thlight.com/uncle-bob/2012/08/13/the-clean-architecture.html">The Clean Architecture</a> and
<a href="http://blog.8thlight.com/uncle-bob/2011/09/30/Screaming-Architecture.html">Screaming Architecture</a> were also useful in
furthering our understaanding of Clean Architecture as defined by Uncle Bob.</p>

<p><a href="https://twitter.com/TotherAlistair">Alistair Cockburn</a> - The <a href="http://alistair.cockburn.us/Hexagonal+architecture">Hexagonal Architecture</a>
ports and adapters concept directly influenced the idea of jacks and plugs in Obvious. In fact, the biggest reason they aren't named ports and adapters in Obvious
is to avoid architecture confusion.</p>

<p></p>

        </section>

      </div>
    </div>
  </body>
</html>
